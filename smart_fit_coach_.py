# -*- coding: utf-8 -*-
"""Smart fit coach .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wH8nA-Hepr8CAf-w_imdz3jNY7j-lFZy
"""

import pandas as pd
import ast
import joblib

# Load dataset
df = pd.read_csv("/content/programs_detailed_boostcamp_kaggle.csv")

# Clean and parse the columns
def safe_parse_list(cell):
    try:
        return ast.literal_eval(cell) if pd.notnull(cell) else []
    except:
        return []

df['goal'] = df['goal'].apply(safe_parse_list)
df['level'] = df['level'].apply(safe_parse_list)

# Extract unique values correctly
unique_goals = sorted(set([item.lower().strip() for sublist in df['goal'] for item in sublist]))
unique_levels = sorted(set([item.lower().strip() for sublist in df['level'] for item in sublist]))
unique_equipment = sorted(df['equipment'].dropna().unique())
unique_times = sorted(df['time_per_workout'].dropna().unique())

print("ðŸ“Œ Unique Fitness Goals:", unique_goals)
print("ðŸ“Œ Unique Levels:", unique_levels)
print("ðŸ“Œ Unique Equipment Needed:", unique_equipment)
print("ðŸ“Œ Unique Workout Times (min/day):", unique_times)

# Function to safely parse stringified lists
def safe_parse_list(x):
    try:
        parsed = ast.literal_eval(x) if isinstance(x, str) and x.startswith('[') else x
        if not isinstance(parsed, list):
            parsed = [parsed]
        flattened_list = []
        for item in parsed:
            if isinstance(item, list):
                flattened_list.extend([subitem.lower().strip() for subitem in item if isinstance(subitem, str)])
            elif isinstance(item, str):
                flattened_list.append(item.lower().strip())
            else:
                flattened_list.append(str(item).lower().strip())
        return flattened_list
    except:
        return []

# Add new program
new_program = {
    "title": "Quick Weight Loss Bodyweight Blast",
    "description": "High-intensity home workout designed to burn fat and promote weight loss.",
    "level": "['beginner']",
    "goal": "['fat loss']",
    "equipment": "bodyweight",
    "program_length": 4.0,
    "time_per_workout": 20.0,
    "Total Exercises": 25,
    "created": "2025-07-22",
    "edited": "2025-07-22"
}



df = pd.concat([df, pd.DataFrame([new_program])], ignore_index=True)

# Rename and clean
df = df.rename(columns={'time_per_workout': 'workout_time'})
df = df.dropna(subset=['title', 'goal', 'level', 'equipment', 'workout_time'])

df['equipment'] = df['equipment'].str.strip().str.lower()
df['workout_time'] = df['workout_time'].astype(str).str.extract('(\d+)').astype(float)
df['program_length'] = df['program_length'].astype(str).str.extract('(\d+)').astype(float)

df['goal'] = df['goal'].apply(safe_parse_list)
df['level'] = df['level'].apply(safe_parse_list)

# Unique options for validation
available_levels = sorted(set([lvl for sublist in df['level'] for lvl in sublist]))
available_goals = sorted(set([g for sublist in df['goal'] for g in sublist]))
available_equipment = df['equipment'].unique().tolist()

# Recommendation function
def recommend_fitness_program(level, goal, time_available, equipment_access):
    level = level.lower()
    goal = goal.lower()
    equipment_access = equipment_access.lower()

    if level not in available_levels:
        return {"error": f"Invalid level. Choose from: {available_levels}"}
    if goal not in available_goals:
        return {"error": f"Invalid goal. Choose from: {available_goals}"}
    if equipment_access not in available_equipment:
        return {"error": f"Invalid equipment. Choose from: {available_equipment}"}

    filtered = df[
        df['level'].apply(lambda lst: level in lst) &
        df['goal'].apply(lambda lst: goal in lst) &
        (df['equipment'] == equipment_access) &
        (df['workout_time'] <= time_available)
    ]

    if not filtered.empty:
        result = filtered.sort_values(by='workout_time').iloc[0]
        return {
            "Program Title": result['title'],
            "Goal(s)": result['goal'],
            "Level(s)": result['level'],
            "Equipment Needed": result['equipment'],
            "Workout Time per Exercise": int(result['workout_time']),
            "Program Length (weeks)": int(result['program_length']),
            "Description": result['description']
        }

    else:
        return {"message": "No suitable program found for the selected preferences."}

# Save updated data and model
df.to_csv("updated_programs_detailed.csv", index=False)
joblib.dump((df, recommend_fitness_program), "fitness_program_model.pkl")

recommend_fitness_program(
    level="advanced",
    goal="bodybuilding",
    time_available=50,
    equipment_access="Full Gym"
)

recommend_fitness_program(
    level="advanced",
    goal="bodybuilding",
    time_available=50,
    equipment_access="Full Gym"
)